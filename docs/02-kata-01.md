# Kata 01 — Recomposition Storm: State Placement & Parameter Stability

## 1) Context
We have a simple Compose screen:
- a list of items (e.g., “characters/products”)
- each item has a “favorite” toggle
- the screen supports a search query and a filter/sort
- there is a detail screen (optional for this kata)

The **start** version is intentionally flawed: small interactions cause large recompositions and confusing state ownership.

Branches:
- `kata-01/start` (intentionally flawed)
- `kata-01/solution` (production-grade refactor)

---

## 2) Symptoms (what’s wrong?)
In the `start` branch you may notice one or more of these:

- Toggling favorite on one item causes the whole list to “work” too much.
- Scroll feels heavier than it should (even with simple UI).
- Item UI state “jumps” when list changes (missing stable keys).
- Derived values (filter/sort) are recalculated on every recomposition.
- Callbacks capture too much state and get recreated often.
- State is stored in the wrong place (business state living inside item composables).

**Goal of the kata:** reduce unnecessary work without turning the code into unreadable micro-optimizations.

---

## 3) Definition of Done (what “good” looks like)
By the end of the kata:

### State ownership
- Business state (favorites, query, filters) is owned by a single state owner (ViewModel or parent).
- UI-only transient state (e.g., expanded/collapsed) is local and clearly scoped.

### List correctness
- `LazyColumn` uses stable keys (e.g., `key = { it.id }`).
- Item state does not jump when list reorders or filters change.

### Parameter stability & decomposition
- Item composables receive **only what they need** (small, stable parameters).
- Callbacks are shaped to avoid capturing large state objects.
- Expensive derived computations are cached with intentional keys.

### Validation
- Simple tests exist for the state updates (e.g., toggle favorite).
- The UI remains correct under filtering/sorting.
- (Optional) recomposition count decreases / workload feels smaller.

---

## 4) Anti-goals (don’t do this)
- Don’t “optimize everything” blindly.
- Don’t add a complex framework (no need for a full MVI framework).
- Don’t hide bugs with random `remember` calls.
- Don’t move all state into composables just to reduce recompositions.
- Don’t introduce global singletons for state.

---

## 5) Step-by-step plan (refactoring checklist)

### Step 1 — Identify state types and owners
Write down:
- Screen state: query, filter/sort, loading/error flags
- Domain/business state: favorites, selected item
- UI transient state: expanded rows, local animations

Decide:
- What lives in ViewModel/parent?
- What can be local to a composable?

### Step 2 — Fix list identity (stable keys)
- Ensure every item has a stable unique `id`
- Apply:
    - `items(items, key = { it.id }) { ... }`

### Step 3 — Reduce parameter “blast radius”
- Avoid passing a huge `UiState` object into each row.
- Prefer passing:
    - `title: String`, `isFavorite: Boolean`, `onToggleFavorite: (id) -> Unit`
- Keep row composables small and focused.

### Step 4 — Make models predictable
- Prefer immutable models (`data class`)
- Avoid mutating lists in place.
- If you must transform data, do it in a single place (VM/mapper).

### Step 5 — Cache expensive derived work intentionally
If you filter/sort/map in Compose:
- Use `remember(query, filter, items) { ... }` or `derivedStateOf { ... }`
- Ensure keys represent the real inputs
- Don’t cache with wrong keys (risk: stale UI)

### Step 6 — Separate UI transient state from business state
Example:
- “expanded” can be local (and optionally `rememberSaveable`)
- “favorite” should NOT be local if it’s business state

### Step 7 — Add lightweight tests for state updates
- Unit test for favorite toggling
- Unit test for filtering/sorting transformation (if present)

---

## 6) Validation (how to verify)
### Functional checks
- Toggle favorite → only that item changes visually.
- Apply filter/sort → favorites remain correct.
- Scroll → list does not jump and item state does not move to other rows.

### Test checks
- Unit tests pass for state transitions (favorite toggle, filtering).
- Optional UI test: favorite click updates expected row.

### Optional inspection (nice-to-have)
- Use Compose tooling to observe recompositions and confirm reduction.
  (Do not make the kata dependent on tooling output.)

---

## 7) Trade-offs (what you should be able to explain)
### 1) Optimization vs readability
We optimize only when it reduces real work. Micro-optimizations that harm clarity are avoided.

### 2) Local state vs hoisted state
- Local state is great for UI-only behavior.
- Hoisted state improves testability and consistency for business rules.
  Trade-off: hoisting adds structure/boilerplate.

### 3) `remember`/`derivedStateOf` vs recalculating
Caching reduces repeated work but increases correctness risk if keys are wrong (stale UI).

### 4) Smaller composables vs fragmentation
Smaller components can reduce unnecessary work, but too many layers can create “prop drilling” and complexity.

### 5) Stable keys vs “quick implementation”
Keys require a stable `id` and discipline, but prevent subtle bugs and state jumping.

---

## 8) Interview hooks (questions this kata answers)
- “How do you reduce unnecessary recompositions in Compose?”
- “When would you keep state local vs hoist it?”
- “How do you handle expensive derived UI computations?”
- “Why do stable keys matter in LazyColumn?”
- “How do you balance performance and maintainability in UI code?”
