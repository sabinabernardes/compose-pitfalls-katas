# Kata 02 — The Side-Effect Trap: One-off Events Done Right

## 1) Context
We have a Compose screen that triggers **one-off** actions:
- navigation (go to detail, open a dialog, etc.)
- snackbar/toast messages
- analytics events
- system actions (open URL, request permission)

The **start** version is intentionally flawed: events can fire multiple times due to recomposition, configuration changes, or incorrect effect keys.

Branches:
- `kata-02/start` (intentionally flawed)
- `kata-02/solution` (production-grade refactor)

---

## 2) Symptoms (what’s wrong?)
In the `start` branch you may notice one or more of these:

- Snackbars appear twice (or on every recomposition).
- Navigation happens multiple times after a single click.
- The same error message replays after rotation / process recreation.
- Analytics logs fire multiple times without user action.
- Effects depend on unstable keys, causing re-execution.

**Goal of the kata:** make side effects **deterministic** and prevent duplicated execution.

---

## 3) Definition of Done (what “good” looks like)

### Separation
- Continuous UI state (what the UI shows) is separated from transient events (what the UI does once).

### Determinism
- Clicking once produces one navigation/snackbar.
- Recomposition alone never triggers side effects.
- Rotation/recreation does not replay old one-off events.

### Correct effect handling
- `LaunchedEffect` keys are intentional and stable.
- Event collection is lifecycle-aware (when applicable).
- Event handling does not capture stale callbacks/state.

### Validation
- Unit tests cover event emission behavior (exactly-once semantics).
- Optional UI test verifies no duplicated navigation/snackbar.

---

## 4) Anti-goals (don’t do this)
- Don’t store one-off events directly inside persistent UI state as a plain string/flag that stays `true`.
- Don’t “fix” duplication by adding random `delay()` or boolean hacks.
- Don’t build a giant architecture framework.
- Don’t trigger navigation/snackbar directly from composable recomposition without an event stream.

---

## 5) Step-by-step plan (refactoring checklist)

### Step 1 — Classify what is state vs event
Write down:
- **State:** loading, list items, selected filters, error state (persistent)
- **Events:** “show snackbar”, “navigate”, “open external link” (transient)

Rule of thumb:
- If it should survive recomposition and be shown again → state
- If it should happen once and disappear → event

### Step 2 — Model events explicitly
Introduce a UI event type, e.g. a sealed class:
- `NavigateToDetail(id)`
- `ShowSnackbar(message)`
- `OpenUrl(url)`

### Step 3 — Emit events from a single owner
Emit events from a single source (usually the ViewModel):
- UI sends user intents/actions
- VM updates state and emits events

### Step 4 — Collect events in Compose using an effect
In the UI:
- collect the event stream in `LaunchedEffect(Unit)` (or a stable key)
- handle events inside the coroutine
- route to navigator/snackbar host

### Step 5 — Ensure events are not replayed unintentionally
Pick an event mechanism with “exactly once” expectations:
- No replay by default (good for nav/snackbar)
- If replay exists, it must be intentional and bounded

### Step 6 — Avoid stale captures
If event handlers use lambdas that can change, ensure you don’t capture stale references.
(Keep references stable or use patterns that avoid stale closures.)

### Step 7 — Add tests for event behavior
- One click → one event emitted
- Recomposition/collecting again does not emit old events automatically
- Optional: verify ordering (snackbar then navigation, etc.)

---

## 6) Validation (how to verify)

### Functional checks
- Trigger an error once → snackbar appears once.
- Click an item once → navigate once.
- Rotate the device / recreate activity → no repeated snackbar/navigation.

### Test checks
- ViewModel test asserts exactly one event is emitted per action.
- If state updates happen, they don’t implicitly cause event repetition.

---

## 7) Trade-offs (what you should be able to explain)

### 1) “Events inside state” vs separate event stream
**Events-in-state** (e.g., `uiState.snackbarMessage != null`) is tempting and simple,
but it’s easy to accidentally replay it after recomposition or recreation.

**Separate events** add structure, but give deterministic one-off behavior.

### 2) Reliability vs simplicity
A dedicated event pipeline (events + effect collection) is slightly more code,
but prevents the most common Compose bugs: duplicated navigation/snackbars.

### 3) Replay semantics
Some stream types can replay values; others don’t.
Replay can be useful for “latest state”, but dangerous for one-off events.
Trade-off: determinism vs “late subscribers still see it”.

### 4) Lifecycle awareness
Collecting events without lifecycle awareness can fire events when the UI is not visible
or can leak collectors.
Trade-off: more correct behavior vs extra setup.

### 5) Testing strategy
Testing “exactly once” semantics is easiest when:
- event emission is isolated in the ViewModel
- reducer logic is pure
  Trade-off: requires separating pure logic from effects.

---

## 8) Interview hooks (questions this kata answers)
- “How do you handle one-off events in Compose?”
- “Why can `LaunchedEffect` cause repeated actions?”
- “How do you prevent duplicated navigation/snackbar?”
- “How do you separate UI state from side effects?”
- “How do you test transient events deterministically?”
