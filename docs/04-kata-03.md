# Kata 03 — Spaghetti Flow → State Machine (Deterministic & Testable)

## 1) Context
We have a multi-step user flow (pick one scenario for the kata):
- onboarding (Step 1 → Step 2 → Step 3 → done)
  OR
- login (idle → loading → success/error)
  OR
- permission gating (needs permission → rationale → granted/denied/never-ask-again → degrade mode)

In the **start** branch, the flow is implemented with nested `if/else`, scattered flags, and UI-driven rules.
In the **solution**, we model the flow as a **state machine** with:
- explicit states
- explicit events
- a pure reducer (deterministic)
- isolated side effects

Branches:
- `kata-03/start` (intentionally flawed)
- `kata-03/solution` (production-grade refactor)

---

## 2) Symptoms (what’s wrong?)
In the `start` branch you may notice:

- Many boolean flags (`isLoading`, `hasError`, `showDialog`, `shouldNavigate`, etc.) with unclear precedence.
- UI rules spread across Composables and ViewModel in an ad-hoc way.
- Hard to answer: “What happens if the user retries while loading?”
- Race conditions: multiple requests overlap, duplicated navigation/events.
- Difficult to test: you need to run the UI to validate behavior.

**Goal of the kata:** make the flow behavior explicit, deterministic, and easy to test.

---

## 3) Definition of Done (what “good” looks like)

### Modeling
- The flow is represented by a `State` sealed hierarchy.
- User/system inputs are modeled as `Event`.
- State transitions happen through a pure `reduce(state, event)` function.

### Side effects
- Side effects (network calls, persistence, navigation triggers) are modeled as `Effect`.
- Effects are executed outside the reducer (e.g., in ViewModel), then results come back as Events.

### Determinism
- Same input sequence -> same output states (no hidden rules).
- Concurrency is handled intentionally (e.g., cancel previous request, or ignore duplicates).

### Testing
- Reducer transitions are covered by unit tests.
- One or two “flow tests” validate typical happy/error paths.

---

## 4) Anti-goals (don’t do this)
- Don’t introduce a big framework.
- Don’t keep adding flags until it “works”.
- Don’t put side effects inside the reducer.
- Don’t make Compose responsible for deciding business flow rules.
- Don’t optimize for “less code” at the cost of unclear behavior.

---

## 5) Step-by-step plan (refactoring checklist)

### Step 1 — Write down the flow as a diagram
Example (login):
Idle -> (Submit) -> Loading -> (Success) -> Authenticated
|-> (Failure) -> Error -> (Retry) -> Loading

### Step 2 — Define `State`
Use a sealed class/interface. Example shape:
- `Idle`
- `Loading`
- `Error(message)`
- `Success(user)`

### Step 3 — Define `Event`
Events are inputs:
- user actions: `Submit`, `Retry`, `DismissError`
- results: `LoginSucceeded(user)`, `LoginFailed(error)`

### Step 4 — Define `Effect`
Effects represent work to do:
- `PerformLogin(credentials)`
- `TrackAnalytics(name)` (optional)

### Step 5 — Implement a pure reducer
Create:
`reduce(state: State, event: Event): Next`
Where `Next` includes:
- `state: State`
- `effects: List<Effect>`

Rules:
- no coroutines inside
- no repositories inside
- just logic

### Step 6 — Execute effects in ViewModel (or a dedicated handler)
- ViewModel holds the current state
- on each event:
    - call reducer
    - update state
    - launch effects
- effects produce result events back into the reducer

### Step 7 — Handle concurrency intentionally
Pick one:
- cancel previous and keep latest (common for search/login retry)
- ignore duplicates while loading
- queue events (rare, but sometimes needed)

Document the choice.

### Step 8 — Add unit tests for transitions
At minimum:
- Idle + Submit -> Loading + PerformLogin effect
- Loading + Success -> Success state
- Loading + Failure -> Error state
- Error + Retry -> Loading + PerformLogin effect

---

## 6) Validation (how to verify)

### Functional checks
- Tap Submit once -> goes to Loading once.
- Tap Submit multiple times quickly -> behavior matches your concurrency rule.
- Failure -> shows Error.
- Retry -> returns to Loading and tries again.
- No random duplicated navigation/snackbar.

### Test checks
- Reducer tests cover all transitions (table-driven tests are great here).
- Optional: ViewModel test checks the exact order of state updates and emitted effects/events.

---

## 7) Trade-offs (what you should be able to explain)

### 1) More structure vs faster hacking
A state machine is more upfront code than `if/else`,
but it pays off by making behavior explicit and testable.

### 2) Single reducer vs scattered logic
Centralizing rules in a reducer reduces “surprises”,
but can become large if the flow is not scoped.
Trade-off: clarity vs file size — keep flow scope small.

### 3) Effects modeling
Modeling effects explicitly adds ceremony,
but prevents mixing I/O with business rules and improves testability.

### 4) Concurrency policy
Cancel-latest is responsive but may waste work.
Ignore-while-loading is simpler but can feel unresponsive.
The correct choice depends on the UX and backend constraints.

### 5) Where to store state
ViewModel as single source of truth is predictable,
but local UI state is still valid for purely visual concerns.
Trade-off: testability vs convenience.

---

## 8) Interview hooks (questions this kata answers)
- “How do you model complex UI flows?”
- “How do you make behavior deterministic and testable?”
- “What’s your approach to MVI/UDF and when do you use it?”
- “How do you isolate side effects from business logic?”
- “How do you handle concurrency and retries in a flow?”
